{"version":3,"sources":["../../src/core/utils.js","../../src/core/config.js","../../src/core/queryInstance.js","../../src/core/query.js","../../src/core/queryCache.js","../../src/core/setFocusHandler.js","../../src/react/ReactQueryCacheProvider.js","../../src/react/ReactQueryConfigProvider.js","../../src/react/utils.js","../../src/react/useBaseQuery.js","../../src/react/useQuery.js","../node_modules/date-fns/esm/differenceInWeeks/index.js"],"names":["_uid","uid","cancelledError","isServer","window","noop","Console","console","error","warn","log","functionalUpdate","updater","old","stableStringifyReplacer","_","value","isObject","Object","key","a","Array","isDocumentVisible","document","getQueryArgs","args","queryKey","config","rest","queryFn","getStatusBools","status","isLoading","isSuccess","isError","isIdle","DEFAULT_CONFIG","shared","suspense","queries","queryKeySerializerFn","invalidQueryKey","d","queryHash","obj","JSON","initialStale","enabled","retry","retryDelay","attemptIndex","Math","staleTime","cacheTime","refetchOnWindowFocus","refetchInterval","queryFnParamsFilter","refetchOnMount","isDataEqual","deepEqual","b","length","i","keys","onError","onSuccess","onSettled","useErrorBoundary","mutations","throwOnError","onMutate","defaultConfigRef","current","Error","makeQueryInstance","query","onStateUpdate","instance","id","clearInterval","oldConfig","minInterval","setInterval","result","body","recover","then","Promise","arguments","f","staleTimeout","pact","state","observer","s","callback","_this","onFulfilled","onRejected","thenable","finalizer","makeQuery","queryCache","notifyGlobalListeners","initialData","hasInitialData","isStale","instances","queryReducer","undefined","type","initialStatus","action","clearTimeout","setTimeout","tryFetchData","promise","fn","delay","reject","resolve","fetchMore","originalQueryFn","data","pageVariables","rebuiltPageVariables","awaitBody","shouldContinue","test","nextCursor","pageArgs","fetchMoreInfo","previous","isFetchingMore","newArgs","getCallbackInstances","callbackInstances","cancelled","newState","isFetching","failureCount","markedForGarbageCollection","updatedAt","Date","throwInErrorBoundary","switchActions","makeQueryCache","queryCaches","frozen","defaultConfig","globalListeners","configRef","acc","cb","notify","exact","predicate","deepIncludes","refetchActive","refetchInactive","force","onWindowFocus","navigator","handleFocus","removePreviousHandler","queryCacheContext","React","useQueryCache","configContext","useConfigContext","useQueryArgs","useMountedCallback","mounted","handleSuspense","queryInfo","useBaseQuery","rerender","instanceRef","useQuery","differenceInWeeks","dirtyDateLeft","dirtyDateRight","requiredArgs","diff","differenceInDays","floor","ceil"],"mappings":"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","file":"static/js/2.13195151.chunk.js","sourcesContent":["export const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport function noop() {\n  return void 0\n}\nexport function identity(d) {\n  return d\n}\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    const { queryKey, queryFn, config } = args[0]\n    args = [queryKey, queryFn, config, ...args.slice(1)]\n  } else if (isObject(args[1])) {\n    const [queryKey, config, ...rest] = args\n    args = [queryKey, undefined, config, ...rest]\n  }\n\n  let [queryKey, queryFn, config = {}, ...rest] = args\n\n  queryFn = queryFn || config.queryFn\n\n  return [queryKey, queryFn ? { ...config, queryFn } : config, ...rest]\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport function getStatusBools(status) {\n  return {\n    isLoading: status === statusLoading,\n    isSuccess: status === statusSuccess,\n    isError: status === statusError,\n    isIdle: status === statusIdle,\n  }\n}\n","import { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const DEFAULT_CONFIG = {\n  shared: {\n    suspense: false,\n  },\n  queries: {\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    queryFn: undefined,\n    initialStale: undefined,\n    enabled: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: 0,\n    cacheTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n    refetchInterval: false,\n    queryFnParamsFilter: identity,\n    refetchOnMount: true,\n    isDataEqual: deepEqual,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n  mutations: {\n    throwOnError: false,\n    onMutate: noop,\n    onError: noop,\n    onSuccess: noop,\n    onSettled: noop,\n    useErrorBoundary: false,\n  },\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULT_CONFIG,\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    invalidQueryKey()\n  }\n\n  if (!Array.isArray(queryKey)) {\n    queryKey = [queryKey]\n  }\n\n  if (queryKey.some(d => typeof d === 'function')) {\n    invalidQueryKey()\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  if (!queryHash) {\n    invalidQueryKey()\n  }\n\n  return [queryHash, queryKey]\n}\n\nfunction invalidQueryKey() {\n  throw new Error('A valid query key is required!')\n}\n","import { uid, isServer, isDocumentVisible, Console } from './utils'\n\nexport function makeQueryInstance(query, onStateUpdate) {\n  const instance = {\n    id: uid(),\n    onStateUpdate,\n  }\n\n  instance.clearInterval = () => {\n    clearInterval(instance.refetchIntervalId)\n    delete instance.refetchIntervalId\n  }\n\n  instance.updateConfig = config => {\n    const oldConfig = instance.config\n\n    // Update the config\n    instance.config = config\n\n    if (!isServer) {\n      if (oldConfig?.refetchInterval === config.refetchInterval) {\n        return\n      }\n\n      query.clearIntervals()\n\n      const minInterval = Math.min(\n        ...query.instances.map(d => d.config.refetchInterval || Infinity)\n      )\n\n      if (\n        !instance.refetchIntervalId &&\n        minInterval > 0 &&\n        minInterval < Infinity\n      ) {\n        instance.refetchIntervalId = setInterval(() => {\n          if (\n            query.instances.some(instance => instance.config.enabled) &&\n            (isDocumentVisible() ||\n              query.instances.some(\n                instance => instance.config.refetchIntervalInBackground\n              ))\n          ) {\n            query.fetch()\n          }\n        }, minInterval)\n      }\n    }\n  }\n\n  instance.run = async () => {\n    try {\n      // Perform the refetch for this query if necessary\n      if (\n        query.config.enabled && // Don't auto refetch if disabled\n        !query.wasSuspended && // Don't double refetch for suspense\n        query.state.isStale && // Only refetch if stale\n        (query.config.refetchOnMount || query.instances.length === 1)\n      ) {\n        await query.fetch()\n      }\n\n      query.wasSuspended = false\n    } catch (error) {\n      Console.error(error)\n    }\n  }\n\n  instance.unsubscribe = () => {\n    query.instances = query.instances.filter(d => d.id !== instance.id)\n\n    if (!query.instances.length) {\n      query.clearIntervals()\n      query.cancel()\n\n      if (!isServer) {\n        // Schedule garbage collection\n        query.scheduleGarbageCollection()\n      }\n    }\n  }\n\n  return instance\n}\n","import {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  noop,\n  statusIdle,\n  Console,\n  getStatusBools,\n} from './utils'\nimport { makeQueryInstance } from './queryInstance'\n\nconst actionInit = 'Init'\nconst actionFailed = 'Failed'\nconst actionMarkStale = 'MarkStale'\nconst actionMarkGC = 'MarkGC'\nconst actionFetch = 'Fetch'\nconst actionSuccess = 'Success'\nconst actionError = 'Error'\nconst actionSetState = 'SetState'\n\nexport function makeQuery({\n  queryCache,\n  queryKey,\n  queryHash,\n  config,\n  notifyGlobalListeners,\n}) {\n  const initialData =\n    typeof config.initialData === 'function'\n      ? config.initialData()\n      : config.initialData\n\n  const hasInitialData = typeof initialData !== 'undefined'\n\n  const isStale =\n    !config.enabled ||\n    (typeof config.initialStale === 'function'\n      ? config.initialStale()\n      : config.initialStale ?? !hasInitialData)\n\n  const initialStatus = hasInitialData\n    ? statusSuccess\n    : config.enabled\n    ? statusLoading\n    : statusIdle\n\n  let query = {\n    queryKey,\n    queryHash,\n    config,\n    instances: [],\n    state: queryReducer(undefined, {\n      type: actionInit,\n      initialStatus,\n      initialData,\n      hasInitialData,\n      isStale,\n    }),\n  }\n\n  query.dispatch = action => {\n    query.state = queryReducer(query.state, action)\n    query.instances.forEach(d => d.onStateUpdate(query.state))\n    notifyGlobalListeners()\n  }\n\n  query.scheduleStaleTimeout = () => {\n    if (isServer) return\n    clearTimeout(query.staleTimeout)\n\n    if (query.config.staleTime === Infinity) {\n      return\n    }\n\n    query.staleTimeout = setTimeout(() => {\n      if (queryCache.getQuery(query.queryKey)) {\n        query.invalidate()\n      }\n    }, query.config.staleTime)\n  }\n\n  query.invalidate = () => {\n    clearTimeout(query.staleTimeout)\n    query.dispatch({ type: actionMarkStale })\n  }\n\n  query.scheduleGarbageCollection = () => {\n    if (!queryCache.queries[query.queryHash]) return\n    if (query.config.cacheTime === Infinity) {\n      return\n    }\n    query.dispatch({ type: actionMarkGC })\n    query.cacheTimeout = setTimeout(\n      () => {\n        queryCache.removeQueries(\n          d =>\n            d.state.markedForGarbageCollection &&\n            d.queryHash === query.queryHash\n        )\n      },\n      typeof query.state.data === 'undefined' && query.state.status !== 'error'\n        ? 0\n        : query.config.cacheTime\n    )\n  }\n\n  query.refetch = async () => {\n    try {\n      await query.fetch()\n    } catch (error) {\n      Console.error(error)\n    }\n  }\n\n  query.heal = () => {\n    // Stop the query from being garbage collected\n    clearTimeout(query.cacheTimeout)\n\n    // Mark the query as not cancelled\n    query.cancelled = null\n  }\n\n  query.cancel = () => {\n    query.cancelled = cancelledError\n\n    if (query.cancelPromises) {\n      query.cancelPromises()\n    }\n\n    delete query.promise\n  }\n\n  query.clearIntervals = () => {\n    query.instances.forEach(instance => {\n      instance.clearInterval()\n    })\n  }\n\n  query.setState = updater => query.dispatch({ type: actionSetState, updater })\n\n  query.setData = updater => {\n    // Set data and mark it as cached\n    query.dispatch({ type: actionSuccess, updater })\n\n    // Schedule a fresh invalidation!\n    query.scheduleStaleTimeout()\n  }\n\n  query.clear = () => {\n    clearTimeout(query.staleTimeout)\n    clearTimeout(query.cacheTimeout)\n    clearTimeout(query.retryTimeout)\n    query.clearIntervals()\n    query.cancel()\n    query.dispatch = noop\n    delete queryCache.queries[query.queryHash]\n  }\n\n  query.subscribe = (onStateUpdate = noop) => {\n    const instance = makeQueryInstance(query, onStateUpdate)\n    query.instances.push(instance)\n    query.heal()\n    return instance\n  }\n\n  // Set up the core fetcher function\n  const tryFetchData = async (fn, ...args) => {\n    try {\n      // Perform the query\n      const promise = fn(...query.config.queryFnParamsFilter(args))\n\n      query.cancelPromises = () => promise.cancel?.()\n\n      const data = await promise\n      delete query.shouldContinueRetryOnFocus\n\n      delete query.cancelPromises\n      if (query.cancelled) throw query.cancelled\n\n      return data\n    } catch (error) {\n      delete query.cancelPromises\n      if (query.cancelled) throw query.cancelled\n\n      // If we fail, increase the failureCount\n      query.dispatch({ type: actionFailed })\n\n      // Do we need to retry the request?\n      if (\n        query.config.retry === true ||\n        query.state.failureCount <= query.config.retry ||\n        (typeof query.config.retry === 'function' &&\n          query.config.retry(query.state.failureCount, error))\n      ) {\n        // Only retry if the document is visible\n        if (!isDocumentVisible()) {\n          // set this flag to continue retries on focus\n          query.shouldContinueRetryOnFocus = true\n          // Resolve a\n          return new Promise(noop)\n        }\n\n        delete query.shouldContinueRetryOnFocus\n\n        // Determine the retryDelay\n        const delay = functionalUpdate(\n          query.config.retryDelay,\n          query.state.failureCount\n        )\n\n        // Return a new promise with the retry\n        return await new Promise((resolve, reject) => {\n          // Keep track of the retry timeout\n          query.retryTimeout = setTimeout(async () => {\n            if (query.cancelled) return reject(query.cancelled)\n\n            try {\n              const data = await tryFetchData(fn, ...args)\n              if (query.cancelled) return reject(query.cancelled)\n              resolve(data)\n            } catch (error) {\n              if (query.cancelled) return reject(query.cancelled)\n              reject(error)\n            }\n          }, delay)\n        })\n      }\n\n      throw error\n    }\n  }\n\n  query.fetch = async ({ fetchMore } = {}) => {\n    let queryFn = query.config.queryFn\n\n    if (!queryFn) {\n      return\n    }\n\n    if (query.config.infinite) {\n      const originalQueryFn = queryFn\n\n      queryFn = async () => {\n        const data = []\n        const pageVariables = [...query.pageVariables]\n        const rebuiltPageVariables = []\n\n        do {\n          const args = pageVariables.shift()\n\n          if (!data.length) {\n            // the first page query doesn't need to be rebuilt\n            data.push(await originalQueryFn(...args))\n            rebuiltPageVariables.push(args)\n          } else {\n            // get an up-to-date cursor based on the previous data set\n\n            const nextCursor = query.config.getFetchMore(\n              data[data.length - 1],\n              data\n            )\n\n            // break early if there's no next cursor\n            // otherwise we'll start from the beginning\n            // which will cause unwanted duplication\n            if (!nextCursor) {\n              break\n            }\n\n            const pageArgs = [\n              // remove the last argument (the previously saved cursor)\n              ...args.slice(0, -1),\n              nextCursor,\n            ]\n\n            data.push(await originalQueryFn(...pageArgs))\n            rebuiltPageVariables.push(pageArgs)\n          }\n        } while (pageVariables.length)\n\n        query.state.canFetchMore = query.config.getFetchMore(\n          data[data.length - 1],\n          data\n        )\n        query.pageVariables = rebuiltPageVariables\n\n        return data\n      }\n\n      if (fetchMore) {\n        queryFn = async (...args) => {\n          const { fetchMoreInfo, previous } = fetchMore\n          try {\n            query.setState(old => ({\n              ...old,\n              isFetchingMore: previous ? 'previous' : 'next',\n            }))\n\n            const newArgs = [...args, fetchMoreInfo]\n\n            query.pageVariables[previous ? 'unshift' : 'push'](newArgs)\n\n            const newData = await originalQueryFn(...newArgs)\n\n            const data = previous\n              ? [newData, ...query.state.data]\n              : [...query.state.data, newData]\n\n            query.state.canFetchMore = query.config.getFetchMore(newData, data)\n\n            return data\n          } finally {\n            query.setState(old => ({\n              ...old,\n              isFetchingMore: false,\n            }))\n          }\n        }\n      }\n    }\n\n    // Create a new promise for the query cache if necessary\n    if (!query.promise) {\n      query.promise = (async () => {\n        // If there are any retries pending for this query, kill them\n        query.cancelled = null\n\n        const getCallbackInstances = () => {\n          const callbackInstances = [...query.instances]\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.fallbackInstance)\n          }\n          return callbackInstances\n        }\n\n        try {\n          // Set up the query refreshing state\n          query.dispatch({ type: actionFetch })\n\n          // Try to get the data\n          let data = await tryFetchData(queryFn, ...query.queryKey)\n\n          query.setData(old =>\n            query.config.isDataEqual(old, data) ? old : data\n          )\n\n          getCallbackInstances().forEach(\n            instance =>\n              instance.config.onSuccess &&\n              instance.config.onSuccess(query.state.data)\n          )\n\n          getCallbackInstances().forEach(\n            instance =>\n              instance.config.onSettled &&\n              instance.config.onSettled(query.state.data, null)\n          )\n\n          delete query.promise\n\n          return data\n        } catch (error) {\n          query.dispatch({\n            type: actionError,\n            cancelled: error === query.cancelled,\n            error,\n          })\n\n          delete query.promise\n\n          if (error !== query.cancelled) {\n            getCallbackInstances().forEach(\n              instance =>\n                instance.config.onError && instance.config.onError(error)\n            )\n\n            getCallbackInstances().forEach(\n              instance =>\n                instance.config.onSettled &&\n                instance.config.onSettled(undefined, error)\n            )\n\n            throw error\n          }\n        }\n      })()\n    }\n\n    return query.promise\n  }\n\n  if (query.config.infinite) {\n    query.fetchMore = (\n      fetchMoreInfo = query.state.canFetchMore,\n      { previous = false } = {}\n    ) => query.fetch({ fetchMore: { fetchMoreInfo, previous } })\n  }\n\n  return query\n}\n\nexport function queryReducer(state, action) {\n  const newState = switchActions(state, action)\n\n  return Object.assign(newState, getStatusBools(newState.status))\n}\n\nfunction switchActions(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching: action.initialStatus === 'loading',\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status:\n          typeof state.data !== 'undefined' ? statusSuccess : statusLoading,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n          throwInErrorBoundary: true,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import {\n  isServer,\n  getQueryArgs,\n  deepIncludes,\n  Console,\n  isObject,\n} from './utils'\nimport { defaultConfigRef } from './config'\nimport { makeQuery } from './query'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCaches = [queryCache]\n\nexport function makeQueryCache({ frozen = isServer, defaultConfig } = {}) {\n  // A frozen cache does not add new queries to the cache\n  const globalListeners = []\n\n  const configRef = defaultConfig\n    ? { current: defaultConfig }\n    : defaultConfigRef\n\n  const queryCache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    queryCache.isFetching = Object.values(queryCache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    globalListeners.forEach(d => d(queryCache))\n  }\n\n  queryCache.subscribe = cb => {\n    globalListeners.push(cb)\n    return () => {\n      globalListeners.splice(globalListeners.indexOf(cb), 1)\n    }\n  }\n\n  queryCache.clear = ({ notify = true } = {}) => {\n    Object.values(queryCache.queries).forEach(query => query.clear())\n    queryCache.queries = {}\n    if (notify) {\n      notifyGlobalListeners()\n    }\n  }\n\n  queryCache.getQueries = (predicate, { exact } = {}) => {\n    if (predicate === true) {\n      return Object.values(queryCache.queries)\n    }\n\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = configRef.current.queries.queryKeySerializerFn(predicate)\n\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(queryCache.queries).filter(predicate)\n  }\n\n  queryCache.getQuery = queryKey =>\n    queryCache.getQueries(queryKey, { exact: true })[0]\n\n  queryCache.getQueryData = queryKey =>\n    queryCache.getQuery(queryKey)?.state.data\n\n  queryCache.removeQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.clear())\n  }\n\n  queryCache.cancelQueries = (...args) => {\n    queryCache.getQueries(...args).forEach(query => query.cancel())\n  }\n\n  queryCache.invalidateQueries = async (\n    predicate,\n    { refetchActive = true, refetchInactive = false, exact, throwOnError } = {}\n  ) => {\n    try {\n      return await Promise.all(\n        queryCache.getQueries(predicate, { exact }).map(query => {\n          if (query.instances.length) {\n            if (\n              refetchActive &&\n              query.instances.some(instance => instance.config.enabled)\n            ) {\n              return query.fetch()\n            }\n          } else {\n            if (refetchInactive) {\n              return query.fetch()\n            }\n          }\n\n          return query.invalidate()\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  queryCache.resetErrorBoundaries = () => {\n    queryCache.getQueries(true).forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  queryCache.buildQuery = (userQueryKey, config = {}) => {\n    config = {\n      ...configRef.current.shared,\n      ...configRef.current.queries,\n      ...config,\n    }\n\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = queryCache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { config })\n    } else {\n      query = makeQuery({\n        queryCache,\n        queryKey,\n        queryHash,\n        config,\n        notifyGlobalListeners,\n      })\n\n      if (config.infinite) {\n        if (\n          typeof query.state.canFetchMore === 'undefined' &&\n          typeof query.state.data !== 'undefined'\n        ) {\n          query.state.canFetchMore = config.getFetchMore(\n            query.state.data[query.state.data.length - 1],\n            query.state.data\n          )\n        }\n\n        // Here we seed the pageVariabes for the query\n        if (!query.pageVariables) {\n          query.pageVariables = [[...query.queryKey]]\n        }\n      }\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (!frozen) {\n        queryCache.queries[queryHash] = query\n\n        if (isServer) {\n          notifyGlobalListeners()\n        } else {\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    query.fallbackInstance = {\n      config: {\n        onSuccess: query.config.onSuccess,\n        onError: query.config.onError,\n        onSettled: query.config.onSettled,\n      },\n    }\n\n    return query\n  }\n\n  queryCache.prefetchQuery = async (...args) => {\n    if (\n      isObject(args[1]) &&\n      (args[1].hasOwnProperty('throwOnError') ||\n        args[1].hasOwnProperty('force'))\n    ) {\n      args[3] = args[1]\n      args[1] = undefined\n      args[2] = undefined\n    }\n\n    let [queryKey, config, { force, throwOnError } = {}] = getQueryArgs(args)\n\n    try {\n      const query = queryCache.buildQuery(queryKey, config)\n      if (force || query.state.isStale) {\n        await query.fetch()\n      }\n      return query.state.data\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n      Console.error(err)\n    }\n  }\n\n  queryCache.setQueryData = (queryKey, updater, config = {}) => {\n    let query = queryCache.getQuery(queryKey)\n\n    if (!query) {\n      query = queryCache.buildQuery(queryKey, config)\n    }\n\n    query.setData(updater)\n  }\n\n  return queryCache\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .invalidateQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (!query.instances.some(instance => instance.config.enabled)) {\n            return false\n          }\n\n          if (!query.state.isStale) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so refetching will create new one\n            delete query.promise\n          }\n\n          return query.config.refetchOnWindowFocus\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\nimport { queryCache, makeQueryCache } from '../core'\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear()\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\nimport { DEFAULT_CONFIG, defaultConfigRef } from '../core/config'\n\n//\n\nconst configContext = React.createContext()\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = useConfigContext()\n\n  const newConfig = React.useMemo(() => {\n    const { shared = {}, queries = {}, mutations = {} } = config\n    const {\n      shared: contextShared = {},\n      queries: contextQueries = {},\n      mutations: contextMutations = {},\n    } = configContextValue\n\n    return {\n      shared: {\n        ...contextShared,\n        ...shared,\n      },\n      queries: {\n        ...contextQueries,\n        ...queries,\n      },\n      mutations: {\n        ...contextMutations,\n        ...mutations,\n      },\n    }\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULT_CONFIG) }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { useConfigContext } from './ReactQueryConfigProvider'\n\nimport {\n  uid,\n  isServer,\n  statusError,\n  statusSuccess,\n  getQueryArgs,\n} from '../core/utils'\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function useQueryArgs(args) {\n  const configContext = useConfigContext()\n\n  let [queryKey, config, ...rest] = getQueryArgs(args)\n\n  // Build the final config\n  config = {\n    ...configContext.shared,\n    ...configContext.queries,\n    ...config,\n  }\n\n  return [queryKey, config, ...rest]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (\n    queryInfo.query.config.suspense ||\n    queryInfo.query.config.useErrorBoundary\n  ) {\n    if (\n      queryInfo.query.state.status === statusError &&\n      queryInfo.query.state.throwInErrorBoundary\n    ) {\n      throw queryInfo.error\n    }\n\n    if (\n      queryInfo.query.config.suspense &&\n      queryInfo.status !== statusSuccess &&\n      queryInfo.query.config.enabled\n    ) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.query.fetch()\n    }\n  }\n}\n","import React from 'react'\n\n//\n\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useMountedCallback } from './utils'\n\nexport function useBaseQuery(queryKey, config = {}) {\n  // Make a rerender function\n  const rerender = useMountedCallback(React.useState()[1])\n\n  // Get the query cache\n  const queryCache = useQueryCache()\n\n  // Build the query for use\n  const query = queryCache.buildQuery(queryKey, config)\n\n  // Create a query instance ref\n  const instanceRef = React.useRef()\n\n  // Subscribe to the query when the subscribe function changes\n  React.useEffect(() => {\n    instanceRef.current = query.subscribe(() => rerender({}))\n\n    // Unsubscribe when things change\n    return instanceRef.current.unsubscribe\n  }, [query, rerender])\n\n  // Always update the config\n  React.useEffect(() => {\n    instanceRef.current.updateConfig(config)\n  })\n\n  // Run the instance when the query or enabled change\n  React.useEffect(() => {\n    if (config.enabled && query) {\n      // Just for change detection\n    }\n    instanceRef.current.run()\n  }, [config.enabled, query])\n\n  return {\n    ...query,\n    ...query.state,\n    query,\n  }\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { useQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...useQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n","import differenceInDays from '../differenceInDays/index.js';\nimport requiredArgs from '../_lib/requiredArgs/index.js';\n/**\n * @name differenceInWeeks\n * @category Week Helpers\n * @summary Get the number of full weeks between the given dates.\n *\n * @description\n * Get the number of full weeks between two dates. Fractional weeks are\n * truncated towards zero.\n *\n * One \"full week\" is the distance between a local time in one day to the same\n * local time 7 days earlier or later. A full week can sometimes be less than\n * or more than 7*24 hours if a daylight savings change happens between two dates.\n *\n * To ignore DST and only measure exact 7*24-hour periods, use this instead:\n * `Math.floor(differenceInHours(dateLeft, dateRight)/(7*24))|0`.\n *\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} dateLeft - the later date\n * @param {Date|Number} dateRight - the earlier date\n * @returns {Number} the number of full weeks\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // How many full weeks are between 5 July 2014 and 20 July 2014?\n * var result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))\n * //=> 2\n *\n * // How many full weeks are between\n * // 1 March 2020 0:00 and 6 June 2020 0:00 ?\n * // Note: because local time is used, the\n * // result will always be 8 weeks (54 days),\n * // even if DST starts and the period has\n * // only 54*24-1 hours.\n * var result = differenceInWeeks(\n *   new Date(2020, 5, 1),\n *   new Date(2020, 2, 6)\n * )\n * //=> 8\n */\n\nexport default function differenceInWeeks(dirtyDateLeft, dirtyDateRight) {\n  requiredArgs(2, arguments);\n  var diff = differenceInDays(dirtyDateLeft, dirtyDateRight) / 7;\n  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);\n}"],"sourceRoot":""}